# coding=utf-8
# 
# Read log file generated by rtt.py from network_rtt package, to find out 
# RTT time distribution.
# 

from functools import partial, reduce
from toolz import functoolz
from math import floor
import numpy
import logging
logger = logging.getLogger(__name__)



class TooFewTimeSlots(Exception):
	pass



def readLine(file):
	"""
	[String] file => [String] line (yield one line at a time)

	This is a generator function which reads one line from a file at a time.
	"""
	with open(file) as f:
		for line in f:
			yield line



def infoLine(line):
	"""
	[String] line => [Bool] is the line start with "INFO"
	"""
	try:
		return (line[0:4] == 'INFO')
	except:
		return False



def httpStatus200(line):
	"""
	[String] line => [Bool] does the line contain HTTP status code 200
	Assumption: this line is a "INFO" line.
	
	A typical line recording HTTP response looks like:

	INFO 2019-03-03 11:29:04,531 rtt | 200,2019-03-03 11:29:04.511230,1,0.02,response 1
	"""
	try:
		return (line.split('|')[1].split(',')[0].strip() == '200')
	except:
		# logger.exception('httpStatus200(): {0}'.format(line))
		return False



def correctResponse(line):
	"""
	[String] line => [Bool] does line contain correct response
	Assumption: this line contains http 200 status code.
	
	A typical line recording HTTP response looks like:

	INFO 2019-03-03 11:29:04,531 rtt | 200,2019-03-03 11:29:04.511230,1,0.02,response 1

	If the request number is "1", and the response is "response 1", then
	it's a correct response
	"""
	try:
		requestNum = line.split('|')[1].split(',')[2]
		if ('response ' + requestNum == line.split('|')[1].split(',')[4].strip()):
			return True
		else:
			return False

	except:
		logger.exception('httpStatus200(): {0}'.format(line))
		return False



def latencyFromLine(line):
	"""
	[String] line => [Float] latency

	Assumption: line is the string representing a line with a valid response
	HTTP 200 status code.
	"""
	return float(line.split('|')[1].split(',')[3])



def latencyInterval(t1, t2, line):
	"""
	[Flat] t1, [Float] t2, [String] line => [Bool] Does the request's network
		latency fall into this time interval (t1, t2)

	Assumption: this line is a valid rtt response
	
	INFO 2019-03-03 11:29:04,531 rtt | 200,2019-03-03 11:29:04.511230,1,0.02,response 1
	"""
	try:
		latency = latencyFromLine(line)
		if (t1 < latency) and (latency <= t2):
			return True
		else:
			return False

	except:
		logger.exception('interval(): {0}'.format(line))
		return False



def histogram(latencies, lines):
	"""
	[List] latencies, [List] lines =>
		[List] number of lines falling into each latency interval

	latencies is a list of float numbers: [t1, t2, ... tn]

	We then form a list of latencies based on it:

	[(t1, t2), (t2, t3), ... (t_n-1, tn)]

	The function works as below:

	First of all, each line is mapped to a tuple of True or False, indicating
	whether its latency falls into a particular interval, like below:

	(True, False, False, ...) 
	(False, True, False, ...)
	(True, False, False, ...)

	Second, we map True to 1 and False to 0, so that it becomes

	(1, 0, 0, ...)
	(0, 1, 0, ...)
	(1, 0, 0, ...)
	
	Then, we zip each column into one item, so that we have a list of
	indications of each time interval,

	(1, 0, 1, ...)
	(0, 1, 0, ...)
	(0, 0, 0, ...)

	Finally, we sum each tuple to arrive at the total number of lines falling
	into each time interval.
	"""
	if len(latencies) < 2:
		logger.error('histogram(): {0}'.format(latencies))
		raise TooFewTimeSlots()


	def take2(items, index):
		return items[index:index+2]


	def intervaFunc(timeInterval):
		"""
		[List] timeInterval => [Function Object] a partially applied "interval"
			function

		Where timeInterval is a list [t1, t2]
		"""
		return partial(latencyInterval, timeInterval[0], timeInterval[1])


	intervals = map(partial(take2, latencies), range(len(latencies)-1))
	intervalFunctions = map(intervaFunc, intervals)

	return map(sum \
			  , zip(*map(functoolz.compose(partial(map, lambda x: 1 if x else 0) \
				   		   				  , functoolz.juxt(intervalFunctions)) \
				   		, lines)))



def histogram2(step, lines):
	"""
	[Float] step, [Iterable] lines =>
		[List] number of lines falling into each latency interval, where
		the intervals are:

		[0, step), [step, 2*step), ... [n*step, (n+1)*step)

	"""
	def countLatency(count, latency):
		"""
		[Dictionary] count, [Float] latency => [Dictionary] count

		count represents number of latency falling into each latency interval,
		where 0 represents first latency [0, step), 1 for [step, 2*step), etc.

		0: xx
		1: xx
		"""
		n = floor(latency/step)
		try:
			count[n] = count[n] + 1
		except KeyError:
			count[n] = 1

		return count
		

	return reduce(countLatency, map(latencyFromLine, lines), {})



def analyzeFile2(step, file):
	"""
	[List] latencies, [String] file => [List] number of lines falling into 
											each time interval
	
	
	"""
	return functoolz.compose(partial(histogram2, step)
							, partial(filter, correctResponse) \
						 	, partial(filter, httpStatus200) \
							, partial(filter, infoLine) \
							, readLine)(file)



def analyzeFile(latencies, file):
	"""
	[List] latencies, [String] file => [List] number of lines falling into 
											each time interval
	
	
	"""
	return histogram(latencies \
					 , functoolz.compose(partial(filter, correctResponse) \
									    , partial(filter, httpStatus200) \
									    , partial(filter, infoLine) \
									    , readLine)(file))



if __name__ == '__main__':
	import logging.config
	logging.config.fileConfig('logging.config', disable_existing_loggers=False)

	"""
	Put the log file containing network rtt information into the local
	directory, then do,

	$ python analysis.py <file_name>
	"""

	import sys
	if len(sys.argv) == 1:
		print('Usage: python analysis.py <file_name>')
		sys.exit(1)


	latencies = numpy.arange(0, 0.5, 0.05)
	# print(list(analyzeFile(latencies, sys.argv[1])))
	print(analyzeFile2(0.05, sys.argv[1]))

	"""
	Two output needed:

	1. histogram for latency distribution
	2. mean or 90% percentile latency for each time interval, say 
		9:00am - 9:30am, etc.

	Others like:

	99% or 95% percentile latency over all records
	Total number of records
	Total number of timeouts
	Total number of errors
	"""