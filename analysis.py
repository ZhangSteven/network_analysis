# coding=utf-8
# 
# Read log file generated by rtt.py from network_rtt package, to find out 
# RTT time distribution.
# 

from functools import partial
from toolz import functoolz
import numpy
import logging
logger = logging.getLogger(__name__)



class TooFewTimeSlots(Exception):
	pass



def readLine(file):
	"""
	[String] file => [String] line (yield one line at a time)

	This is a generator function which reads one line from a file at a time.
	"""
	with open(file) as f:
		for line in f:
			yield line



def infoLine(line):
	"""
	[String] line => [Bool] is the line start with "INFO"
	"""
	try:
		return (line[0:4] == 'INFO')
	except:
		return False



def httpStatus200(line):
	"""
	[String] line => [Bool] does the line contain HTTP status code 200
	Assumption: this line is a "INFO" line.
	
	A typical line recording HTTP response looks like:

	INFO 2019-03-03 11:29:04,531 rtt | 200,2019-03-03 11:29:04.511230,1,0.02,response 1
	"""
	try:
		return (line.split('|')[1].split(',')[0].strip() == '200')
	except:
		# logger.exception('httpStatus200(): {0}'.format(line))
		return False



def correctResponse(line):
	"""
	[String] line => [Bool] does line contain correct response
	Assumption: this line contains http 200 status code.
	
	A typical line recording HTTP response looks like:

	INFO 2019-03-03 11:29:04,531 rtt | 200,2019-03-03 11:29:04.511230,1,0.02,response 1

	If the request number is "1", and the response is "response 1", then
	it's a correct response
	"""
	try:
		requestNum = line.split('|')[1].split(',')[2]
		if ('response ' + requestNum == line.split('|')[1].split(',')[4].strip()):
			return True
		else:
			return False

	except:
		logger.exception('httpStatus200(): {0}'.format(line))
		return False



def latencyInterval(t1, t2, line):
	"""
	[Flat] t1, [Float] t2, [String] line => [Bool] Does the request's network
		latency fall into this time interval (t1, t2)

	Assumption: this line is a valid rtt response
	
	INFO 2019-03-03 11:29:04,531 rtt | 200,2019-03-03 11:29:04.511230,1,0.02,response 1
	"""
	try:
		latency = float(line.split('|')[1].split(',')[3])
		if (t1 < latency) and (latency <= t2):
			return True
		else:
			return False

	except:
		logger.exception('interval(): {0}'.format(line))
		return False



def histogram(latencies, lines):
	"""
	[List] latencies, [List] lines =>
		[List] number of lines falling into each latency interval

	latencies is a list of float numbers: [t1, t2, ... tn]

	We then form a list of latencies based on it:

	[(t1, t2), (t2, t3), ... (t_n-1, tn)]

	The function works as below:

	First of all, each line is mapped to a tuple of True or False, indicating
	whether its latency falls into a particular interval, like below:

	(True, False, False, ...) 
	(False, True, False, ...)
	(True, False, False, ...)

	Second, we map True to 1 and False to 0, so that it becomes

	(1, 0, 0, ...)
	(0, 1, 0, ...)
	(1, 0, 0, ...)
	
	Then, we zip each column into one item, so that we have a list of
	indications of each time interval,

	(1, 0, 1, ...)
	(0, 1, 0, ...)
	(0, 0, 0, ...)

	Finally, we sum each tuple to arrive at the total number of lines falling
	into each time interval.
	"""
	if len(latencies) < 2:
		logger.error('histogram(): {0}'.format(latencies))
		raise TooFewTimeSlots()


	def take2(items, index):
		return items[index:index+2]


	def intervaFunc(timeInterval):
		"""
		[List] timeInterval => [Function Object] a partially applied "interval"
			function

		Where timeInterval is a list [t1, t2]
		"""
		return partial(latencyInterval, timeInterval[0], timeInterval[1])


	intervals = map(partial(take2, latencies), range(len(latencies)-1))
	intervalFunctions = map(intervaFunc, intervals)

	return map(sum \
			  , zip(*map(functoolz.compose(partial(map, lambda x: 1 if x else 0) \
				   		   				  , functoolz.juxt(intervalFunctions)) \
				   		, lines)))



def analyzeFile(latencies, file):
	"""
	[List] latencies, [String] file => [List] number of lines falling into 
											each time interval
	
	
	"""
	return histogram(latencies \
					, functoolz.compose(partial(filter, correctResponse) \
									   , partial(filter, httpStatus200) \
									   , partial(filter, infoLine) \
									   , readLine)(file))



if __name__ == '__main__':
	import logging.config
	logging.config.fileConfig('logging.config', disable_existing_loggers=False)

	"""
	Put the log file containing network rtt information into the local
	directory, then do,

	$ python analysis.py <file_name>
	"""

	import sys
	if len(sys.argv) == 1:
		print('Usage: python analysis.py <file_name>')
		sys.exit(1)


	latencies = numpy.arange(0, 0.1, 0.01)
	print(list(analyzeFile(latencies, sys.argv[1])))